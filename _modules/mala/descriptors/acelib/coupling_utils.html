<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mala.descriptors.acelib.coupling_utils &mdash; Materials Learning Algorithms (MALA)  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=33f2f6c7" />

  
    <link rel="shortcut icon" href="../../../../_static/mala_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html">
            
              <img src="../../../../_static/mala_horizontal_white.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../basic_usage.html">Getting started with MALA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_usage.html">Advanced options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing.html">Citing MALA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTE.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Materials Learning Algorithms (MALA)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mala.descriptors.acelib.coupling_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mala.descriptors.acelib.coupling_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions for calculation of ACE coupling coefficients.</span>

<span class="sd">Some of the functions here are specifically related to the PA basis set,</span>
<span class="sd">and formerly lived in the pa_gen.py or pa_lib.py files, before these</span>
<span class="sd">were unified.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sympy.combinatorics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Permutation</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">mala.descriptors.acelib.young</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">YoungSubgroup</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mala.descriptors.acelib.common_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">group_vector_by_nodes</span><span class="p">,</span>
    <span class="n">local_sigma_c_partitions</span><span class="p">,</span>
    <span class="n">filled_perm</span><span class="p">,</span>
    <span class="n">group_vector_by_nodes_pairwise</span><span class="p">,</span>
    <span class="n">check_triangle</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mala.descriptors.acelib.symmetric_group_manipulations</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">leaf_filter</span><span class="p">,</span>
    <span class="n">calculate_degenerate_orbit</span><span class="p">,</span>
    <span class="n">enforce_sorted_orbit</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mala.descriptors.acelib.tree_sorting</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">build_full_tree</span><span class="p">,</span>
    <span class="n">build_quick_tree</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="build_tree_for_l_intermediates">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.build_tree_for_l_intermediates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_tree_for_l_intermediates</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the &quot;intermediate&quot; angular momenta. When coupling N quantum angular momenta (and reducing product of N spherical harmonics in ACE), only 2 quantum angular momenta can be added at a time with traditional clebsch-gordan coefficients.</span>

<span class="sd">    Any more, and they must be reduced to an &#39;intermediate&#39;, and the intermediates added. The allowed intermediates are those determined by repeated quantum angular momentum addition rules (a.k.a. triangle conditions).</span>

<span class="sd">    This function gets all possible sets of intermediates given a set of N angular momentum quantum numbers. This is described in more detail in https://doi.org/10.1016/j.jcp.2024.113073.</span>
<span class="sd">    </span>
<span class="sd">    More detail about the intermediates may be found following Eq. 7 in the above reference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : List</span>
<span class="sd">        list (multiset) of angular momentum indices l1,l2,...lN. These correspond</span>
<span class="sd">        to the N spherical harmonics in the ACE descriptor(s).</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    full_inter_tuples : List</span>
<span class="sd">        List of all possible &quot;intermediate&quot; angular momenta allowed by polygon</span>
<span class="sd">        conditions. See discussion following Eq. 7 in above reference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">base_node_inters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">l</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span>
        <span class="p">}</span>

    <span class="n">full_inter_tuples</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">L1s</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">for</span> <span class="n">L1</span> <span class="ow">in</span> <span class="n">L1s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">remainder</span><span class="p">],</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">L1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">L1L2_prod</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">L1L2</span> <span class="ow">in</span> <span class="n">L1L2_prod</span><span class="p">:</span>
            <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span> <span class="o">=</span> <span class="n">L1L2</span>
            <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                <span class="n">good_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">)</span>
                <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_tuple</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">L1L2_prod</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">next_node_inters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">L1L2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">L1L2</span> <span class="ow">in</span> <span class="n">L1L2_prod</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">L1L2</span><span class="p">,</span> <span class="n">L3l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">L1L2_prod</span><span class="p">,</span> <span class="n">next_node_inters</span><span class="p">):</span>
            <span class="n">L1L2L3s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">L1L2</span><span class="p">],</span> <span class="n">L3l</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">L1L2L3</span> <span class="ow">in</span> <span class="n">L1L2L3s</span><span class="p">:</span>
                <span class="n">L1L2</span><span class="p">,</span> <span class="n">L3</span> <span class="o">=</span> <span class="n">L1L2L3</span>
                <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span> <span class="o">=</span> <span class="n">L1L2</span>
                <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">remainder</span><span class="p">],</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                    <span class="n">good_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">)</span>
                    <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_tuple</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">L1L2L3_prod</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">next_node_inters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2L3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">L1L2L3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">L1L2L3</span> <span class="ow">in</span> <span class="n">L1L2L3_prod</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">L1L2L3</span><span class="p">,</span> <span class="n">L4l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">L1L2L3_prod</span><span class="p">,</span> <span class="n">next_node_inters</span><span class="p">):</span>
            <span class="n">L1L2L3L4s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">L1L2L3</span><span class="p">],</span> <span class="n">L4l</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">L1L2L3L4</span> <span class="ow">in</span> <span class="n">L1L2L3L4s</span><span class="p">:</span>
                <span class="n">L1L2L3</span><span class="p">,</span> <span class="n">L4</span> <span class="o">=</span> <span class="n">L1L2L3L4</span>
                <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span> <span class="o">=</span> <span class="n">L1L2L3</span>
                <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">L3</span><span class="p">,</span> <span class="n">L4</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                    <span class="n">good_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L4</span><span class="p">)</span>
                    <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_tuple</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">L1L2L3_prod</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">next_node_inters_l</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2L3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">L1L2L3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">L1L2L3</span> <span class="ow">in</span> <span class="n">L1L2L3_prod</span>
        <span class="p">]</span>  <span class="c1"># left hand branch</span>
        <span class="n">next_node_inters_r</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2L3</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">remainder</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">L1L2L3</span> <span class="ow">in</span> <span class="n">L1L2L3_prod</span>
        <span class="p">]</span>  <span class="c1"># right hand branch</span>
        <span class="n">next_node_inters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">L4</span><span class="p">,</span> <span class="n">L5</span><span class="p">)</span> <span class="k">for</span> <span class="n">L4</span><span class="p">,</span> <span class="n">L5</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">next_node_inters_l</span><span class="p">,</span> <span class="n">next_node_inters_r</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">L1L2L3</span><span class="p">,</span> <span class="n">L45</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">L1L2L3_prod</span><span class="p">,</span> <span class="n">next_node_inters</span><span class="p">):</span>
            <span class="n">L1L2L3L4L5s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">L1L2L3</span><span class="p">],</span> <span class="o">*</span><span class="n">L45</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">L1L2L3L4L5</span> <span class="ow">in</span> <span class="n">L1L2L3L4L5s</span><span class="p">:</span>
                <span class="n">L1L2L3l</span><span class="p">,</span> <span class="n">L4</span><span class="p">,</span> <span class="n">L5</span> <span class="o">=</span> <span class="n">L1L2L3L4L5</span>
                <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span> <span class="o">=</span> <span class="n">L1L2L3l</span>
                <span class="c1"># L4 , L5 = L45l</span>
                <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">L4</span><span class="p">,</span> <span class="n">L5</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                    <span class="n">good_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L4</span><span class="p">,</span> <span class="n">L5</span><span class="p">)</span>
                    <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_tuple</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">L1L2L3L4_prod</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                <span class="n">base_node_inters</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">next_node_inters_l</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2L3L4</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">L1L2L3L4</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">L1L2L3L4</span> <span class="ow">in</span> <span class="n">L1L2L3L4_prod</span>
        <span class="p">]</span>  <span class="c1"># left hand branch</span>
        <span class="n">next_node_inters_r</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">compute_intermediates</span><span class="p">(</span><span class="n">L1L2L3L4</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">L1L2L3L4</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">L1L2L3L4</span> <span class="ow">in</span> <span class="n">L1L2L3L4_prod</span>
        <span class="p">]</span>  <span class="c1"># right hand branch</span>
        <span class="c1"># next_node_inters = [tuple(L5+L6) for L5,L6 in zip(next_node_inters_l,</span>
        <span class="c1"># next_node_inters_r)]</span>
        <span class="n">next_node_inters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">L5</span><span class="p">,</span> <span class="n">L6</span><span class="p">)</span> <span class="k">for</span> <span class="n">L5</span><span class="p">,</span> <span class="n">L6</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">next_node_inters_l</span><span class="p">,</span> <span class="n">next_node_inters_r</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># print(&#39;next level&#39;,next_node_inters)</span>
        <span class="k">for</span> <span class="n">L1L2L3L4</span><span class="p">,</span> <span class="n">L56</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">L1L2L3L4_prod</span><span class="p">,</span> <span class="n">next_node_inters</span><span class="p">):</span>
            <span class="n">L1L2L3L4L5L6s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">L1L2L3L4</span><span class="p">],</span> <span class="o">*</span><span class="n">L56</span><span class="p">))</span>
            <span class="c1"># print(L1L2L3L4L5L6s)</span>
            <span class="c1"># L1L2L3L4L5L6s = list(itertools.product([L1L2L3L4] , [L56]))</span>
            <span class="k">for</span> <span class="n">L1L2L3L4L5L6</span> <span class="ow">in</span> <span class="n">L1L2L3L4L5L6s</span><span class="p">:</span>
                <span class="c1"># L1L2L3L4l , L56l = L1L2L3L4L5L6</span>
                <span class="n">L1L2L3L4l</span><span class="p">,</span> <span class="n">L5</span><span class="p">,</span> <span class="n">L6</span> <span class="o">=</span> <span class="n">L1L2L3L4L5L6</span>
                <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L4</span> <span class="o">=</span> <span class="n">L1L2L3L4l</span>
                <span class="c1"># L5 , L6 = L56l</span>
                <span class="k">if</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">L5</span><span class="p">,</span> <span class="n">L6</span><span class="p">,</span> <span class="n">L_R</span><span class="p">):</span>
                    <span class="n">good_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L4</span><span class="p">,</span> <span class="n">L5</span><span class="p">,</span> <span class="n">L6</span><span class="p">)</span>
                    <span class="n">full_inter_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_tuple</span><span class="p">)</span>
        <span class="c1"># print(&#39;full inters&#39;,full_inter_tuples)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rank </span><span class="si">%d</span><span class="s2"> not implemented&quot;</span> <span class="o">%</span> <span class="n">rank</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full_inter_tuples</span></div>



<div class="viewcode-block" id="generate_l_LR">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.generate_l_LR">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_l_LR</span><span class="p">(</span><span class="n">lrng</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_permutations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the possible combinations of angular momentum quantum numbers for a given rank. This takes into account that the desired descriptors will, in general, be rotationally invariant.</span>

<span class="sd">    In short, this function enumerates all possible angular basis function indices for a given descriptor rank (before reducing according to rules defined in Eq. 33 of https://doi.org/10.1016/j.jcp.2024.113073.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lrng : List</span>
<span class="sd">        list of int of possible angular momentum quantum numbers. Typically, </span>
<span class="sd">        these will be (0,1,2...lmax)</span>

<span class="sd">    rank : int</span>
<span class="sd">        order of the expansion, referred to as `N` in Drautz 2019, of the</span>
<span class="sd">        descriptors to be enumerated</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    M_R : int</span>
<span class="sd">        Resultant projection quantum number. This also determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. M_R must obey</span>
<span class="sd">        -L_R &lt;= M_R &lt;= L_R</span>

<span class="sd">    use_permutations : bool</span>
<span class="sd">        Logical flag to generate all non-repeating permutations of `l` for</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ls : List</span>
<span class="sd">        List of angular momenta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">L_R</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># symmetric w.r.t. inversion</span>
        <span class="n">inv_parity</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">L_R</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># odd spherical harmonics are antisymmetric w.r.t. inversion</span>
        <span class="n">inv_parity</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">llst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
    <span class="n">lstr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">llst</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">L_R</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">all_l_perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">lrng</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">rank</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">use_permutations</span><span class="p">:</span>
            <span class="n">all_ls</span> <span class="o">=</span> <span class="n">all_l_perms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">use_permutations</span><span class="p">:</span>
            <span class="c1"># eliminate redundant couplings by only considering lexicographically ordered l_i</span>
            <span class="n">all_ls</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ltup</span> <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_l_perms</span> <span class="k">if</span> <span class="n">ltup</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ltup</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                    <span class="n">parity_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_R</span><span class="p">,))</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                    <span class="n">parity_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_R</span><span class="p">,))</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">check_triangle</span><span class="p">(</span><span class="n">ltup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ltup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">L_R</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_flag</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ltup</span><span class="p">[</span><span class="n">remainder</span><span class="p">],</span> <span class="n">L_R</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">L_R</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ltup</span><span class="p">[</span><span class="n">remainder</span><span class="p">],</span> <span class="n">L_R</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">L_R</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                        <span class="n">check_triangle</span><span class="p">(</span>
                            <span class="n">inters_i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ltup</span><span class="p">[</span><span class="n">remainder</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">L_R</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ltup</span> <span class="ow">in</span> <span class="n">all_ls</span><span class="p">:</span>
                <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ltup</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
                <span class="n">by_node</span> <span class="o">=</span> <span class="n">group_vector_by_nodes_pairwise</span><span class="p">(</span>
                    <span class="n">ltup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">inters_i</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
                    <span class="n">li_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inter</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">by_node</span><span class="p">,</span> <span class="n">inters_i</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">inter_flags</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
                        <span class="n">check_triangle</span><span class="p">(</span><span class="n">inters_i</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">inters_i</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">L_R</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">li_flags</span> <span class="o">+</span> <span class="n">inter_flags</span>
                    <span class="k">if</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">inv_parity</span><span class="p">:</span>
                        <span class="n">parity_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ltup</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parity_all</span><span class="p">:</span>
                        <span class="n">lsub</span> <span class="o">=</span> <span class="n">lstr</span> <span class="o">%</span> <span class="n">ltup</span>
                        <span class="k">if</span> <span class="n">lsub</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                            <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsub</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ls</span></div>



<div class="viewcode-block" id="compute_intermediates">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.compute_intermediates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_intermediates</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute integers lying between absolute difference and sum of l1 and l2.</span>
<span class="sd">    </span>
<span class="sd">    This function enumerates possible third angular momentum quantum numbers that obey the triangle conditions for quantum angular momentum addition.</span>
<span class="sd">    </span>
<span class="sd">    See &quot;Definitions&quot; in https://doi.org/10.1016/j.jcp.2024.113073.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l1 : int</span>
<span class="sd">        First angular momentum quantum number</span>

<span class="sd">    l2 : int</span>
<span class="sd">        Second angular momentum quantum number</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ints : List</span>
<span class="sd">        List of all integers between abs(l1-l2) and l1+l2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">tris</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">),</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">l2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="n">ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tris</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ints</span></div>



<div class="viewcode-block" id="compute_pa_labels_raw">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.compute_pa_labels_raw">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_pa_labels_raw</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">mumax</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M_R</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumerate permutation-adapted ACE descriptors (ace descriptors obeying eq. 33 in https://doi.org/10.1016/j.jcp.2024.113073).</span>

<span class="sd">    For ranks &lt;=3, this simply uses lexicographically ordered indices. This function enumerates all ACE descriptor labels of rank N, up to a maximumum radial index and up to a maximum angular function index (angular momentum number for spherical harmonics).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rank : int</span>
<span class="sd">        order of the expansion, referred to as `N` in Drautz 2019, of the</span>
<span class="sd">        descriptors to be enumerated</span>

<span class="sd">    nmax : any</span>
<span class="sd">        maximum radial basis function index for the given descriptor rank</span>

<span class="sd">    lmax : any</span>
<span class="sd">        maximum angular momentum number for the given descriptor rank (maximum angular function index)</span>

<span class="sd">    mumax : any</span>
<span class="sd">        maximum chemical basis index for the given rank (should generally be </span>
<span class="sd">        mumax=len(ace_elements)</span>

<span class="sd">    lmin : any</span>
<span class="sd">        minimum angular momentum number for the given descriptor rank</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    M_R : int</span>
<span class="sd">        Resultant projection quantum number. This also determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. M_R must obey</span>
<span class="sd">        -L_R &lt;= M_R &lt;= L_R</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_lammps_labels : List</span>
<span class="sd">        PA labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">all_max_l</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">all_max_n</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">all_max_mu</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">label_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
            <span class="s2">&quot;all_labels_mu</span><span class="si">%d</span><span class="s2">_n</span><span class="si">%d</span><span class="s2">_l</span><span class="si">%d</span><span class="s2">_r</span><span class="si">%d</span><span class="s2">.json&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">all_max_mu</span><span class="p">,</span>
                <span class="n">all_max_n</span><span class="p">,</span>
                <span class="n">all_max_l</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">label_file</span><span class="p">):</span>
            <span class="n">build_and_write_to_tabulated</span><span class="p">(</span>
                <span class="n">rank</span><span class="p">,</span> <span class="n">all_max_n</span><span class="p">,</span> <span class="n">all_max_l</span><span class="p">,</span> <span class="n">label_file</span><span class="p">,</span> <span class="n">L_R</span><span class="p">,</span> <span class="n">M_R</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">label_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">readjson</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">readjson</span><span class="p">)</span>

        <span class="c1"># This part does not seem to be needed at the moment.</span>
        <span class="c1"># lmax_strs = generate_l_LR(</span>
        <span class="c1">#     range(lmin, lmax + 1), rank, L_R=L_R, M_R=M_R</span>
        <span class="c1"># )</span>
        <span class="c1"># lvecs = [</span>
        <span class="c1">#     tuple([int(k) for k in lmax_str.split(&quot;,&quot;)])</span>
        <span class="c1">#     for lmax_str in lmax_strs</span>
        <span class="c1"># ]</span>
        <span class="c1"># nvecs = [i for i in itertools.combinations_with_replacement(range(0,nmax),rank)]</span>
        <span class="n">muvecs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">mumax</span><span class="p">),</span> <span class="n">rank</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># reduced_nvecs=get_mapped_subset(nvecs)</span>

        <span class="n">all_lammps_labs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># all_not_compat = []</span>
        <span class="n">possible_mus</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mumax</span><span class="p">))</span>

        <span class="n">lmax_strs</span> <span class="o">=</span> <span class="n">generate_l_LR</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">rank</span><span class="p">,</span>
            <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">,</span>
            <span class="n">M_R</span><span class="o">=</span><span class="n">M_R</span><span class="p">,</span>
            <span class="n">use_permutations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lvecs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lmax_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">lmax_str</span> <span class="ow">in</span> <span class="n">lmax_strs</span>
        <span class="p">]</span>
        <span class="n">nvecs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rank</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">nlprd</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">nvecs</span><span class="p">,</span> <span class="n">lvecs</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">muvec</span> <span class="ow">in</span> <span class="n">muvecs</span><span class="p">:</span>
            <span class="n">muvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">muvec</span><span class="p">)</span>
            <span class="c1"># for nlblockstr in list(data[&#39;labels&#39;].keys()):</span>
            <span class="c1">#    nstr,lstr = tuple(nlblockstr.split(&#39;_&#39;))</span>
            <span class="c1">#    nvec = tuple([int(k) + 1 for k in nstr.split(&#39;,&#39;)])</span>
            <span class="c1">#    lvec = tuple([int(k) for k in lstr.split(&#39;,&#39;)])</span>
            <span class="k">for</span> <span class="n">nlv</span> <span class="ow">in</span> <span class="n">nlprd</span><span class="p">:</span>
                <span class="n">nvec</span><span class="p">,</span> <span class="n">lvec</span> <span class="o">=</span> <span class="n">nlv</span>
                <span class="n">nvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nvec</span><span class="p">)</span>
                <span class="n">lvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lvec</span><span class="p">)</span>
                <span class="c1"># nus = from_tabulated((0,0,0,0),(1,1,1,1),(4,4,4,4),allowed_mus = possible_mus, tabulated_all = data)</span>
                <span class="n">nus</span> <span class="o">=</span> <span class="n">read_from_tabulated</span><span class="p">(</span>
                    <span class="n">muvec</span><span class="p">,</span>
                    <span class="n">nvec</span><span class="p">,</span>
                    <span class="n">lvec</span><span class="p">,</span>
                    <span class="n">allowed_mus</span><span class="o">=</span><span class="n">possible_mus</span><span class="p">,</span>
                    <span class="n">tabulated_all</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">lammps_ready</span><span class="p">,</span> <span class="n">not_compatible</span> <span class="o">=</span> <span class="n">lammps_remap</span><span class="p">(</span>
                    <span class="n">nus</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">allowed_mus</span><span class="o">=</span><span class="n">possible_mus</span>
                <span class="p">)</span>
                <span class="n">all_lammps_labs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lammps_ready</span><span class="p">)</span>
                <span class="c1"># all_not_compat.extend(not_compatible)</span>

                <span class="c1"># print (&#39;raw PA-RPI&#39;,nus)</span>
                <span class="c1"># print (&#39;lammps ready PA-RPI&#39;,lammps_ready)</span>
                <span class="c1"># print (&#39;not compatible with lammps (PA-RPI with a nu vector that cannot be reused)&#39;,not_compatible)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no symmetry reduction required for rank &lt;= 3</span>
        <span class="c1"># use typical lexicographical ordering for such cases</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">generate_nl</span><span class="p">(</span>
            <span class="n">rank</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">mumax</span><span class="o">=</span><span class="n">mumax</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="n">lmin</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">,</span> <span class="n">all_perms</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">all_lammps_labs</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="c1"># all_not_compat = []</span>

    <span class="k">return</span> <span class="n">all_lammps_labs</span></div>



<div class="viewcode-block" id="generate_nl">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.generate_nl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_nl</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">mumax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">all_perms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate lexicographically ordered n,l tuples. (useful for enumerating ACE descriptor labels up to rank 3.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rank: int</span>
<span class="sd">        order of the expansion, referred to as `N` in Drautz 2019, of the</span>
<span class="sd">        descriptors to be enumerated</span>

<span class="sd">    nmax : any</span>
<span class="sd">        maximum radial basis function index for the given descriptor rank</span>

<span class="sd">    lmax : any</span>
<span class="sd">        maximum angular momentum number for the given descriptor rank</span>

<span class="sd">    mumax : any</span>
<span class="sd">        maximum chemical basis index for the given rank (should generally be</span>
<span class="sd">        mumax=len(ace_elements)</span>

<span class="sd">    lmin : any</span>
<span class="sd">        minimum angular momentum number for the given descriptor rank</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    all_perms : bool</span>
<span class="sd">        logical flag to include redundant permutations of ACE descriptor labels.</span>
<span class="sd">        This should only be used for testing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    munl : List</span>
<span class="sd">        List of munl vectors in string format, i.e.</span>
<span class="sd">        mu0_mu1,mu2,...muk,n1,n2,..n_k,l1,l2,..l_k_L1-L2...-LK</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">munl</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">murng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">mumax</span><span class="p">)</span>
    <span class="n">nrng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lrng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mus</span> <span class="o">=</span> <span class="n">create_unique_combinations</span><span class="p">(</span><span class="n">murng</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">create_unique_combinations</span><span class="p">(</span><span class="n">nrng</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="n">generate_l_LR</span><span class="p">(</span><span class="n">lrng</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">L_R</span><span class="p">)</span>

    <span class="n">linters_per_l</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">l</span><span class="p">:</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)],</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ls</span>
    <span class="p">}</span>

    <span class="n">munllst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">rank</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">munlstr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">munllst</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mu0</span> <span class="ow">in</span> <span class="n">murng</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cmbo</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
            <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">cmbo</span>

            <span class="n">linters</span> <span class="o">=</span> <span class="n">linters_per_l</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="n">musplt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
            <span class="n">nsplt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
            <span class="n">lsplt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[(</span><span class="n">musplt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lsplt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nsplt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">)]</span>
            <span class="n">srt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_perms</span><span class="p">:</span>
                <span class="n">conds</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">srt</span>
            <span class="k">elif</span> <span class="n">all_perms</span><span class="p">:</span>
                <span class="n">conds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lsplt</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lsplt</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">conds</span><span class="p">:</span>
                <span class="n">stmp</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="n">mu0</span> <span class="o">+</span> <span class="n">munlstr</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">musplt</span> <span class="o">+</span> <span class="n">nsplt</span> <span class="o">+</span> <span class="n">lsplt</span><span class="p">)</span>
                <span class="c1"># if stmp not in munl:</span>
                <span class="k">for</span> <span class="n">linter</span> <span class="ow">in</span> <span class="n">linters</span><span class="p">:</span>
                    <span class="n">linter_str_lst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">linter</span><span class="p">)</span>
                    <span class="n">linter_str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">linter_str_lst</span><span class="p">)</span> <span class="o">%</span> <span class="n">linter</span>
                    <span class="n">munlL</span> <span class="o">=</span> <span class="n">stmp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">linter_str</span>
                    <span class="n">munl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">munlL</span><span class="p">)</span>
    <span class="n">munl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">munl</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">munl</span></div>



<div class="viewcode-block" id="get_mapped_subset">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.get_mapped_subset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_mapped_subset</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map n indices to a new set of indices based on the frequency of elements in n rather than the values of n themselves.</span>

<span class="sd">    This tool is to allow one to more conveniently order indices in their respective frequency partitions, as needed by Eq. 33 in https://doi.org/10.1016/j.jcp.2024.113073.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ns : List</span>
<span class="sd">        List of possible n multisets</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reduced_ns : List</span>
<span class="sd">        Returns a list of n multisets that have been reordered according to the frequency</span>
<span class="sd">        of elements of n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapped_n_per_n</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_per_mapped_n</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">unique_ns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">tmpn</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tmpn</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mp_n</span> <span class="o">=</span> <span class="p">{</span><span class="n">unique_ns</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ns</span><span class="p">))}</span>
        <span class="n">mprev_n</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">unique_ns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ns</span><span class="p">))}</span>
        <span class="n">mappedn</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp_n</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmpn</span><span class="p">]</span>
        <span class="n">mappedn</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mappedn</span><span class="p">)</span>
        <span class="n">mapped_n_per_n</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mappedn</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_per_mapped_n</span><span class="p">[</span><span class="n">mappedn</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">n_per_mapped_n</span><span class="p">[</span><span class="n">mappedn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_per_mapped_n</span><span class="p">[</span><span class="n">mappedn</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">reduced_ns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mappedn</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">n_per_mapped_n</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">reduced_ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">n_per_mapped_n</span><span class="p">[</span><span class="n">mappedn</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">reduced_ns</span></div>



<div class="viewcode-block" id="build_and_write_to_tabulated">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.build_and_write_to_tabulated">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_and_write_to_tabulated</span><span class="p">(</span>
    <span class="n">rank</span><span class="p">,</span> <span class="n">all_max_n</span><span class="p">,</span> <span class="n">all_max_l</span><span class="p">,</span> <span class="n">label_file</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M_R</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a tabulated PA ACE descriptor label file.</span>

<span class="sd">    This only matters for rank &gt;=4. The json files build in this function are saved in the acelib directory and read in the process of computing the labels/coupling coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rank : int</span>
<span class="sd">        body order of angular ace descriptor labels to be generated</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    M_R : int</span>
<span class="sd">        Resultant projection quantum number. This also determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. M_R must obey</span>
<span class="sd">        -L_R &lt;= M_R &lt;= L_R</span>

<span class="sd">    all_max_n : int</span>
<span class="sd">        max radial basis function index (with possible shift according to max chemical </span>
<span class="sd">        basis index)</span>

<span class="sd">    all_max_l : int</span>
<span class="sd">        max angular basis function index</span>

<span class="sd">    label_file : str</span>
<span class="sd">        file name to contain PA labels</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None : None</span>
<span class="sd">        Labels are written to file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lmax_strs</span> <span class="o">=</span> <span class="n">generate_l_LR</span><span class="p">(</span>
        <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">all_max_l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rank</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">,</span> <span class="n">M_R</span><span class="o">=</span><span class="n">M_R</span><span class="p">,</span> <span class="n">use_permutations</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">lvecs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lmax_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lmax_str</span> <span class="ow">in</span> <span class="n">lmax_strs</span>
    <span class="p">]</span>
    <span class="n">nvecs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">all_max_n</span><span class="p">),</span> <span class="n">rank</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="n">reduced_nvecs</span> <span class="o">=</span> <span class="n">get_mapped_subset</span><span class="p">(</span><span class="n">nvecs</span><span class="p">)</span>

    <span class="n">all_PA_tabulated</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">PA_per_nlblock</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">nin</span> <span class="ow">in</span> <span class="n">reduced_nvecs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lin</span> <span class="ow">in</span> <span class="n">lvecs</span><span class="p">:</span>
            <span class="n">max_labs</span><span class="p">,</span> <span class="n">all_labs</span><span class="p">,</span> <span class="n">labels_per_block</span><span class="p">,</span> <span class="n">original_spans</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">generate_tree_labels</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">lin</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">combined_labs</span> <span class="o">=</span> <span class="n">combine_blocks</span><span class="p">(</span><span class="n">labels_per_block</span><span class="p">,</span> <span class="n">lin</span><span class="p">)</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">lin</span><span class="p">)</span>
            <span class="n">lspan_perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_spans</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">parity_span</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">original_spans</span><span class="p">[</span><span class="n">lspan_perm</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lspan_perm</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lspan_perm</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">]</span>
            <span class="n">PA_labels</span> <span class="o">=</span> <span class="n">apply_ladder_relationships</span><span class="p">(</span>
                <span class="n">lin</span><span class="p">,</span>
                <span class="n">nin</span><span class="p">,</span>
                <span class="n">combined_labs</span><span class="p">,</span>
                <span class="n">parity_span</span><span class="p">,</span>
                <span class="n">parity_span_labs</span><span class="o">=</span><span class="n">max_labs</span><span class="p">,</span>
                <span class="n">full_span</span><span class="o">=</span><span class="n">original_spans</span><span class="p">[</span><span class="n">lspan_perm</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">nstrlst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
            <span class="n">lstrlst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
            <span class="n">Lstrlst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">nl_simple_labs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlstr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">PA_labels</span><span class="p">:</span>
                <span class="n">mu0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">simple_str</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Lstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
                <span class="p">)</span>
                <span class="n">all_PA_tabulated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simple_str</span><span class="p">)</span>
                <span class="n">nl_simple_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simple_str</span><span class="p">)</span>
            <span class="n">PA_per_nlblock</span><span class="p">[</span><span class="n">nlstr</span><span class="p">]</span> <span class="o">=</span> <span class="n">nl_simple_labs</span>

    <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;labels&quot;</span><span class="p">:</span> <span class="n">PA_per_nlblock</span><span class="p">}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span>
        <span class="n">label_file</span><span class="p">,</span>
        <span class="s2">&quot;w&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">writejson</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">writejson</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="read_from_tabulated">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.read_from_tabulated">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_from_tabulated</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">allowed_mus</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tabulated_all</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read PA ACE descriptor labels from tabulated data saved to a json file (by build_tabulated).</span>

<span class="sd">    Since functions are only tabulated for n-l a conversion is made to include chemical basis indices as well and make sure that they are permutation-adapted independent as well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu : List</span>
<span class="sd">        list of chemical basis indices mu1,mu2,...muN </span>

<span class="sd">    n : List</span>
<span class="sd">        list of radial basis indices n1,n2,...nN</span>

<span class="sd">    l : List</span>
<span class="sd">        list of radial basis indices l1,l2,...lN</span>

<span class="sd">    allowed_mus : List</span>
<span class="sd">        all possible allowed chemical basis function indices. (generated by range(mumax))</span>

<span class="sd">    tabulated_all : dict</span>
<span class="sd">        optionally, pass in tabulated PA ACE descriptor labels as a dictionary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chem_labels : List</span>
<span class="sd">        Labels read from json file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="n">Lveclst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">vecstrlst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
    <span class="n">mun_tupped</span> <span class="o">=</span> <span class="n">combine_muvector_nvector</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">all_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mun_tup</span> <span class="ow">in</span> <span class="n">mun_tupped</span><span class="p">:</span>
        <span class="n">mappedn</span><span class="p">,</span> <span class="n">mappedl</span><span class="p">,</span> <span class="n">mprev_n</span><span class="p">,</span> <span class="n">mprev</span> <span class="o">=</span> <span class="n">get_mapped</span><span class="p">(</span><span class="n">mun_tup</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">this_key_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">mappedn</span>
            <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">these_labels</span> <span class="o">=</span> <span class="n">tabulated_all</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="n">this_key_str</span><span class="p">]</span>
        <span class="n">mapped_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># print (mappedn,this_key_str)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">these_labels</span><span class="p">:</span>
            <span class="n">radstr</span><span class="p">,</span> <span class="n">lstr</span><span class="p">,</span> <span class="n">Lstr</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">radvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">radstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span>
            <span class="n">lvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span>
            <span class="n">Lvec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Lstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span>
            <span class="n">Lstr_std</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Lveclst</span><span class="p">)</span> <span class="o">%</span> <span class="n">Lvec</span>
            <span class="n">remapped_radvec</span> <span class="o">=</span> <span class="p">[</span><span class="n">mprev_n</span><span class="p">[</span><span class="n">rdv</span><span class="p">]</span> <span class="k">for</span> <span class="n">rdv</span> <span class="ow">in</span> <span class="n">radvec</span><span class="p">]</span>
            <span class="n">mulab</span> <span class="o">=</span> <span class="p">[</span><span class="n">rdv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">rdv</span> <span class="ow">in</span> <span class="n">remapped_radvec</span><span class="p">]</span>
            <span class="n">nlab</span> <span class="o">=</span> <span class="p">[</span><span class="n">rdv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">rdv</span> <span class="ow">in</span> <span class="n">remapped_radvec</span><span class="p">]</span>
            <span class="n">mulab</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mulab</span><span class="p">)</span>
            <span class="n">nlab</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nlab</span><span class="p">)</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">mulab</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">nlab</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">lvec</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="n">Lstr_std</span>
            <span class="p">)</span>
            <span class="c1"># print (nu)</span>
            <span class="n">mapped_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
        <span class="n">all_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mapped_labels</span><span class="p">)</span>

    <span class="n">chem_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mu0</span> <span class="ow">in</span> <span class="n">allowed_mus</span><span class="p">:</span>
        <span class="n">mu0_prefix</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="n">mu0</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">all_labels</span><span class="p">:</span>
            <span class="n">chemlabel</span> <span class="o">=</span> <span class="n">mu0_prefix</span> <span class="o">+</span> <span class="n">label</span>
            <span class="n">chem_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chemlabel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chem_labels</span></div>



<div class="viewcode-block" id="get_mapped">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.get_mapped">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_mapped</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">lin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort n and l multisets by frequency of occurence of elements in nin and lin.</span>

<span class="sd">    For nin, elements of nin are ordered according to their frequency, and a new index is assigned to elements of nin based on their frequency of occurence. The map between these two is saved.</span>

<span class="sd">    For lin, elements of lin are ordered according to their frequency, and a new index is assigned to elements of lin based on their frequency of occurence. The map between these two is saved.</span>

<span class="sd">    This function is used to avoid redundant enumeration for radial and angular function index multisets with the same frequency partitions as others.</span>

<span class="sd">    For example n=(1,1,2,2), l=(1,1,3,5) uses the same frequency partition as n=(2,2,3,3), l=(3,3,4,6). This function makes sure these two cases are handledwith the same frequency partition.</span>

<span class="sd">    For example, nin = [2,3,3,4] -&gt; mappedn = [0,0,1,2], mprev_n = {0:3,1:2,2:4} and lin = [1,1,1,3] -&gt; mappedl = [0,0,0,1], mprev = {0:1,1:3}.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nin : List</span>
<span class="sd">        radial indices to resort according to frequency and return the mapping to do so</span>

<span class="sd">    lin : List</span>
<span class="sd">        angular indices to resort according to frequency and return the mapping to do so</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mappedn : tuple</span>
<span class="sd">        frequency-sorted indices for nin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lin</span><span class="p">))</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">uniques</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">uniques</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="n">uniques</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniques</span><span class="p">))}</span>
    <span class="n">mprev</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">uniques</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniques</span><span class="p">))}</span>
    <span class="n">mappedl</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">]</span>

    <span class="n">unique_ns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nin</span><span class="p">))</span>
    <span class="n">tmpn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tmpn</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mp_n</span> <span class="o">=</span> <span class="p">{</span><span class="n">unique_ns</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ns</span><span class="p">))}</span>
    <span class="n">mprev_n</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">unique_ns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ns</span><span class="p">))}</span>
    <span class="n">mappedn</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp_n</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmpn</span><span class="p">]</span>
    <span class="n">mappedn</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mappedn</span><span class="p">)</span>
    <span class="n">mappedl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mappedl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mappedn</span><span class="p">,</span> <span class="n">mappedl</span><span class="p">,</span> <span class="n">mprev_n</span><span class="p">,</span> <span class="n">mprev</span></div>



<div class="viewcode-block" id="combine_muvector_nvector">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.combine_muvector_nvector">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_muvector_nvector</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tuple vectors mu and n. Adds chemical basis to radial basis indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu : List</span>
<span class="sd">        multiset of chemical basis indices</span>

<span class="sd">    n : List</span>
<span class="sd">        multiset of radial basis indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuppled : List</span>
<span class="sd">        combined chemical and radial basis indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="c1"># n = sorted(n)</span>
    <span class="n">umus</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">mu</span><span class="p">))))</span>
    <span class="n">uns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">n</span><span class="p">))))</span>
    <span class="n">combos</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmb</span> <span class="k">for</span> <span class="n">cmb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">umus</span><span class="p">,</span> <span class="n">uns</span><span class="p">)]</span>
    <span class="n">tupped</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([(</span><span class="n">ni</span><span class="p">,</span> <span class="n">mui</span><span class="p">)</span> <span class="k">for</span> <span class="n">mui</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cmb</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">cmb</span> <span class="ow">in</span> <span class="n">combos</span>
    <span class="p">]</span>
    <span class="n">tupped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tupped</span><span class="p">))</span>
    <span class="c1"># uniques = []</span>
    <span class="c1"># for tupi in tupped:</span>
    <span class="c1">#     nil = []</span>
    <span class="c1">#     muil = []</span>
    <span class="c1">#     for tupii in tupi:</span>
    <span class="c1">#         muil.append(tupii[1])</span>
    <span class="c1">#         nil.append(tupii[0])</span>
    <span class="c1">#     uniques.append(tuple([tuple(muil), tuple(nil)]))</span>
    <span class="k">return</span> <span class="n">tupped</span></div>



<div class="viewcode-block" id="create_unique_combinations">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.create_unique_combinations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_unique_combinations</span><span class="p">(</span><span class="n">lrng</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create all unique combinations of a size from integers in a range. Useful for enumerating index multisets where repetition of indices is allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lrng : range</span>
<span class="sd">        Range of l-values.</span>

<span class="sd">    size : int</span>
<span class="sd">        Size of combinations to be created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uniques : List</span>
<span class="sd">        List of unique combinations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">combs</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">lrng</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combs</span><span class="p">:</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">:</span>
            <span class="n">pstr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pstr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uniques</span><span class="p">:</span>
                <span class="n">uniques</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniques</span></div>



<div class="viewcode-block" id="calculate_mu_n_l">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.calculate_mu_n_l">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_mu_n_l</span><span class="p">(</span><span class="n">nu_in</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an ACE descriptor label, nu, return the chemical basis function indices, radial basis function indices, and angular basis function indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nu_in : str</span>
<span class="sd">        ACE descriptor label in FitSNAP/LAMMPS format</span>
<span class="sd">        mu0_mu1,mu2...muN,n1,n2...nN,l1,l2...lN_L1-L2-...-L_{N-3}-L_{N-2}</span>

<span class="sd">    return_L : bool</span>
<span class="sd">        Flag to return multiset of intermediate angular indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mu_n_l : tuple</span>
<span class="sd">        Tuple containing mu0, mu, n and l (and L, if return_L is True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">calculate_mu_nu_rank</span><span class="p">(</span><span class="n">nu_in</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Lstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Lstr</span> <span class="o">=</span> <span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nusplt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">nusplt</span><span class="p">[:</span><span class="n">rank</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nusplt</span><span class="p">[</span><span class="n">rank</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rank</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">nusplt</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Lstr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Lstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">return_L</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span>
    <span class="c1"># provide option to get n,l for depricated descriptor labels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_in</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="n">nusplt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nusplt</span><span class="p">[:</span><span class="n">rank</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">nusplt</span><span class="p">[</span><span class="n">rank</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rank</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span></div>



<div class="viewcode-block" id="calculate_mu_nu_rank">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.calculate_mu_nu_rank">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_mu_nu_rank</span><span class="p">(</span><span class="n">nu_in</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate mu-nu rank from nu. Given an ACE descriptor label in FitSNAP/LAMMPS format, return the rank of the descriptor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nu_in : str</span>
<span class="sd">        ACE descriptor label in FitSNAP/LAMMPS format</span>
<span class="sd">        mu0_mu1,mu2...muN,n1,n2...nN,l1,l2...lN_L1-L2-...-L_{N-3}-L_{N-2}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mu_nu_rank : int</span>
<span class="sd">        Rank computed from label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;make sure your descriptor label is in proper format: mu0_mu1,mu2,&quot;</span>
            <span class="s2">&quot;mu3,n1,n2,n3,l1,l2,l3_L1&quot;</span>
        <span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nu_splt</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nu_splt</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_in</span>
        <span class="n">nu_splt</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nu_splt</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="lammps_remap">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.lammps_remap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lammps_remap</span><span class="p">(</span><span class="n">PA_labels</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">allowed_mus</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remap PA labels for LAMMPS. Takes (tabulated) PA labels enumerated with n and l multisets, and adds in chemical basis indices.</span>

<span class="sd">    In other words, this function maps munl PA labels to nl labels compatible with lammps .yace basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    PA_labels : List</span>
<span class="sd">        List of PA labels to be remapped.</span>

<span class="sd">    rank : int</span>
<span class="sd">        Rank used for the remapping.</span>

<span class="sd">    allowed_mus : List</span>
<span class="sd">        Allowed mu values for the remapping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    remapped : tuple</span>
<span class="sd">        Tuple contain the remapped labels that are compatible with lammps descriptor calculators and,</span>
<span class="sd">        in very rare cases, labels that are not compatible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transforms_all</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
        <span class="p">],</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
        <span class="p">],</span>
    <span class="p">}</span>  <span class="c1"># correct for left vs right cycles in sympy</span>
    <span class="n">leaf_to_internal_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">4</span><span class="p">:</span> <span class="p">{</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
        <span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
            <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms_all</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">as_perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>

    <span class="n">Lveclst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">vecstrlst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>

    <span class="n">all_nl</span> <span class="o">=</span> <span class="p">{</span><span class="n">mu0</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">mu0</span> <span class="ow">in</span> <span class="n">allowed_mus</span><span class="p">}</span>
    <span class="n">fs_labs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">not_compatible</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">PA_labels</span><span class="p">:</span>
        <span class="n">mu0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">Lraw</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mu</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
        <span class="n">nl_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">mui</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">li</span><span class="p">)</span> <span class="k">for</span> <span class="n">mui</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">nl</span> <span class="ow">in</span> <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]:</span>
            <span class="n">nlperms</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="p">(</span><span class="n">nl_tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">as_perms</span><span class="p">]</span>
            <span class="n">perm_source</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                <span class="p">):</span> <span class="n">transform</span>
                <span class="k">for</span> <span class="n">nlp</span><span class="p">,</span> <span class="n">transform</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nlperms</span><span class="p">,</span> <span class="n">transforms</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1"># print (&#39;perm source&#39;,perm_source)</span>
            <span class="n">notins</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">nlp</span> <span class="ow">in</span> <span class="n">nlperms</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">notins</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no other possible labels for LAMMPS&quot;</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span>
            <span class="n">added_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nlpermsitr</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">nlperms</span><span class="p">)</span>
            <span class="n">nlp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">nlpermsitr</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">added_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># for nlp in nlperms:</span>
                    <span class="n">nlnew</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="n">nli</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">nli</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">]),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">nlnew</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]:</span>
                        <span class="n">permtup</span> <span class="o">=</span> <span class="n">leaf_to_internal_map</span><span class="p">[</span><span class="n">rank</span><span class="p">][</span>
                            <span class="n">perm_source</span><span class="p">[</span><span class="n">nlnew</span><span class="p">]</span>
                        <span class="p">]</span>
                        <span class="n">perm_L</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">filled_perm</span><span class="p">(</span><span class="n">permtup</span><span class="p">,</span> <span class="n">rank</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))(</span>
                            <span class="n">Lraw</span>
                        <span class="p">)</span>
                        <span class="n">L</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perm_L</span><span class="p">)</span>
                        <span class="n">mustr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">nlnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">nlnew</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">lstr</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vecstrlst</span><span class="p">)</span> <span class="o">%</span> <span class="n">nlnew</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">Lstr</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Lveclst</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
                        <span class="n">nustr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">mu0</span><span class="p">,</span>
                            <span class="n">mustr</span><span class="p">,</span>
                            <span class="n">nstr</span><span class="p">,</span>
                            <span class="n">lstr</span><span class="p">,</span>
                            <span class="n">Lstr</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nlnew</span><span class="p">)</span>
                        <span class="n">fs_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nustr</span><span class="p">)</span>
                        <span class="n">added_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nlp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">nlpermsitr</span><span class="p">)</span>
                        <span class="c1"># print (&#39;already used new nl&#39;)</span>
                        <span class="c1"># break</span>
                        <span class="c1"># print (&#39;already used nl label for:&#39;,lab)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">notins</span><span class="p">):</span>
                    <span class="n">not_compatible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fs_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
            <span class="n">all_nl</span><span class="p">[</span><span class="n">mu0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fs_labs</span><span class="p">,</span> <span class="n">not_compatible</span></div>



<div class="viewcode-block" id="simple_parity_filter">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.simple_parity_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">simple_parity_filter</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">inters</span><span class="p">,</span> <span class="n">even</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter possible couplings according to parity of intermediates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : List</span>
<span class="sd">        collection of angular momentum quantum numbers [l1,l2,...lN]</span>

<span class="sd">    inters :</span>
<span class="sd">        possible multisets of intermediates [(L1,L2...L_{N-2}),(L1&#39;,L2&#39;,...L_{N-2})&#39; ...]</span>

<span class="sd">    even : bool</span>
<span class="sd">        Control for which parity to filter according to. (For L_R=0 - will use &#39;even&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inters_filt : List</span>
<span class="sd">        Filtered multisets of intermediates obeying parity constraints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">build_quick_tree</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="n">base_ls</span> <span class="o">=</span> <span class="n">group_vector_by_nodes</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">remainder</span><span class="o">=</span><span class="n">remainder</span><span class="p">)</span>
    <span class="n">base_ls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">base_ls</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">even</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;must have \sum</span><span class="si">{l_i}</span><span class="s2"> = even for even parity definition&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">inters_filt</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inters</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">base_ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">base_ls</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remainder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inters_filt</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">i</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inters</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">+</span> <span class="n">base_ls</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base_ls</span><span class="p">))</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inters_filt</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">i</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inters</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">+</span> <span class="n">base_ls</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base_ls</span><span class="p">))</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;must have \sum</span><span class="si">{l_i}</span><span class="s2"> = odd for odd parity definition&quot;</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;WARNING! You are using an odd parity tree. Check your labels to &quot;</span>
            <span class="s2">&quot;make sure this is what you want (this is for fitting vector &quot;</span>
            <span class="s2">&quot;quantities!)&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">inters_filt</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inters</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">base_ls</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inters</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Odd parity not implemented for rank != 4&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inters_filt</span></div>



<div class="viewcode-block" id="calculate_highest_coupling_representation">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.calculate_highest_coupling_representation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_highest_coupling_representation</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">lref</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the partition of N that has the biggest cycles that are multiples of 2.</span>

<span class="sd">    This is used to help define the recursion relationships assigned per frequency partition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lp : List</span>
<span class="sd">        permutation of l indices</span>

<span class="sd">    lref : List</span>
<span class="sd">        sorted indices of l</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    highest_rep : tuple</span>
<span class="sd">        partition of N with maximized cycles which are powers of 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
    <span class="n">coupling_reps</span> <span class="o">=</span> <span class="n">local_sigma_c_partitions</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">ysgi</span> <span class="o">=</span> <span class="n">YoungSubgroup</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
    <span class="n">highest_rep</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">coupling_reps</span><span class="p">:</span>
        <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span><span class="n">lref</span><span class="p">,</span> <span class="p">[</span><span class="n">rep</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">test_fills</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_fills</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">highest_rep</span> <span class="o">=</span> <span class="n">rep</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">highest_rep</span></div>



<div class="viewcode-block" id="generate_tree_labels">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.generate_tree_labels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_tree_labels</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">lin</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts nl according to frequency partitions, not necessarily lexicographically.</span>

<span class="sd">    This is just a special ordering of n and l multisets that is more compatible with the application of quantum angular momentum &quot;ladder opertations&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nin : List</span>
<span class="sd">        input collection of radial basis function indices</span>

<span class="sd">    lin : List</span>
<span class="sd">        input collection of angular basis function indices</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tree_labels : tuple</span>
<span class="sd">        Tuple containing max_labs, all_labs, labels_per_block and</span>
<span class="sd">        original_spans.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="n">ysgi</span> <span class="o">=</span> <span class="n">YoungSubgroup</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lin</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">lin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">nin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span>

    <span class="c1"># get possible unique l permutations based on degeneracy and coupling tree</span>
    <span class="c1"># structure</span>
    <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span>
        <span class="n">lin</span><span class="p">,</span>
        <span class="n">partitions</span><span class="o">=</span><span class="p">[</span><span class="n">local_sigma_c_partitions</span><span class="p">[</span><span class="n">rank</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
        <span class="n">max_orbit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">local_sigma_c_partitions</span><span class="p">[</span><span class="n">rank</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">lperms</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">lperms</span> <span class="o">=</span> <span class="n">leaf_filter</span><span class="p">(</span><span class="n">lperms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">]:</span>
        <span class="n">lperms_tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">used_hrep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lperm</span> <span class="ow">in</span> <span class="n">lperms</span><span class="p">:</span>
            <span class="n">hrep</span> <span class="o">=</span> <span class="n">calculate_highest_coupling_representation</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">lperm</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lperms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">hrep</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_hrep</span><span class="p">:</span>
                <span class="n">used_hrep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hrep</span><span class="p">)</span>
                <span class="n">lperms_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lperm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">lperms</span> <span class="o">=</span> <span class="n">lperms_tmp</span>
    <span class="n">original_joint_span</span> <span class="o">=</span> <span class="p">{</span><span class="n">lp</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">lperms</span><span class="p">}</span>
    <span class="n">orb_nls</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">ls</span> <span class="o">=</span> <span class="n">lperms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nps_per_l</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># get n permutations per l permutation</span>
    <span class="c1"># this could equivalently be done with a search over S_N</span>
    <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
        <span class="n">original_span_SO3</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>  <span class="c1"># RI basis size</span>
        <span class="n">degen_orbit</span><span class="p">,</span> <span class="n">orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span>
            <span class="n">lp</span>
        <span class="p">)</span>  <span class="c1"># PI basis size</span>
        <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="p">[</span><span class="n">degen_orbit</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">degen_fills</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sequential_degen_orbit</span> <span class="o">=</span> <span class="n">enforce_sorted_orbit</span><span class="p">(</span><span class="n">orbit_inds</span><span class="p">)</span>
        <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="p">[</span><span class="n">sequential_degen_orbit</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">nps_per_l</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">original_joint_span</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">prd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lp</span><span class="p">,</span> <span class="n">prd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">prd</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">degen_fills</span><span class="p">,</span> <span class="n">original_span_SO3</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">labels_per_lperm</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># build all labels (unsorted trees)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">subblock</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">L_R</span><span class="o">=</span><span class="n">L_R</span><span class="p">)</span>
        <span class="n">nperms</span> <span class="o">=</span> <span class="n">nps_per_l</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
        <span class="n">muperms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="n">inters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">muperm</span> <span class="ow">in</span> <span class="n">muperms</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nperm</span> <span class="ow">in</span> <span class="n">nperms</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                                <span class="n">orb_nls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;0_</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">muperm</span> <span class="o">+</span> <span class="n">nperm</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">inter</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">subblock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;0_</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">muperm</span> <span class="o">+</span> <span class="n">nperm</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">inter</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="n">orb_nls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;0_</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">muperm</span> <span class="o">+</span> <span class="n">nperm</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">inter</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">subblock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;0_</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">muperm</span> <span class="o">+</span> <span class="n">nperm</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">inter</span><span class="p">)</span>
                                <span class="p">)</span>
        <span class="n">labels_per_lperm</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">subblock</span>

    <span class="n">block_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">labels_per_lperm</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">all_labs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels_per_block</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">block</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">block_sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="p">}</span>
    <span class="n">counts_per_block</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">block_sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))}</span>

    <span class="c1"># collect sorted trees only</span>
    <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">labs</span> <span class="ow">in</span> <span class="n">labels_per_lperm</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">used_ns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">used_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">labs</span><span class="p">:</span>
            <span class="n">mu0</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ntst</span><span class="p">,</span> <span class="n">ltst</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ltree</span> <span class="o">=</span> <span class="p">[(</span><span class="n">li</span><span class="p">,</span> <span class="n">ni</span><span class="p">)</span> <span class="k">for</span> <span class="n">ni</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ntst</span><span class="p">,</span> <span class="n">ltst</span><span class="p">)]</span>  <span class="c1"># sort first on n</span>
            <span class="n">tree_i</span> <span class="o">=</span> <span class="n">build_full_tree</span><span class="p">(</span><span class="n">ltree</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L_R</span><span class="p">)</span>
            <span class="n">tid</span> <span class="o">=</span> <span class="n">tree_i</span><span class="o">.</span><span class="n">tree_id</span>
            <span class="n">conds</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_ids</span>
            <span class="p">)</span>  <span class="c1"># sorting is ensured in construction of trees</span>
            <span class="k">if</span> <span class="n">conds</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ntst</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_ns</span><span class="p">:</span>
                    <span class="n">used_ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ntst</span><span class="p">))</span>
                <span class="n">used_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
                <span class="n">labels_per_block</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
                <span class="n">counts_per_block</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">all_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="c1"># collect labels per l permutation block</span>
    <span class="n">max_labs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts_per_block</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">tree_labs</span> <span class="ow">in</span> <span class="n">labels_per_block</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_labs</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_count</span><span class="p">:</span>
            <span class="n">max_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_labs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">max_labs</span> <span class="o">=</span> <span class="n">max_labs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">max_labs</span><span class="p">,</span> <span class="n">all_labs</span><span class="p">,</span> <span class="n">labels_per_block</span><span class="p">,</span> <span class="n">original_joint_span</span></div>



<div class="viewcode-block" id="combine_blocks">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.combine_blocks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">lin</span><span class="p">,</span> <span class="n">L_R</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recombine trees from multiple permutations of l.</span>

<span class="sd">    Combines &#39;blocks&#39; of functions after rearranging l according to frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    blocks : dict</span>
<span class="sd">        labels per block (could use a new name)</span>

<span class="sd">    lin : List</span>
<span class="sd">        unique (nominally sorted) l</span>

<span class="sd">    L_R : int</span>
<span class="sd">        Resultant angular momentum quantum number. This determines the equivariant</span>
<span class="sd">        character of the rank N descriptor after reduction. L_R=0 corresponds to</span>
<span class="sd">        a rotationally invariant feature, L_R=1 corresponds to a feature that</span>
<span class="sd">        transforms like a vector, L_R=2 a tensor, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    combined_labs : List</span>
<span class="sd">        combined lL labels for the frequency partition of l (defining the &#39;block&#39; of</span>
<span class="sd">        angular functions to work with).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="n">lps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">blockpairs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block1</span><span class="p">,</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">lps</span><span class="p">,</span> <span class="n">lps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block1</span> <span class="o">!=</span> <span class="n">block2</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blockpairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">blockpairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">)</span> <span class="k">for</span> <span class="n">block1</span><span class="p">,</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">lps</span><span class="p">,</span> <span class="n">lps</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="n">block_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">blockpair</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="n">blockpairs</span><span class="p">}</span>
    <span class="n">all_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">blockpair</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="n">blockpairs</span><span class="p">}</span>
    <span class="n">L_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">blockpair</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="n">blockpairs</span><span class="p">}</span>
    <span class="n">raw_perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">)))]</span>
    <span class="n">Ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">raw_perms</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">block_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">l1i</span><span class="p">,</span> <span class="n">l2i</span> <span class="o">=</span> <span class="n">blockpair</span>
        <span class="n">is_sigma0</span> <span class="o">=</span> <span class="n">l1i</span> <span class="o">==</span> <span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Pl1is</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Ps</span> <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">l1i</span><span class="p">)))</span> <span class="o">==</span> <span class="n">l2i</span><span class="p">]</span>
        <span class="n">Pl1_maxorbit_sizes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">full_cyclic_form</span><span class="p">])</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Pl1is</span>
        <span class="p">]</span>
        <span class="n">maxorbit_all</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Pl1_maxorbit_sizes</span><span class="p">)</span>
        <span class="n">maxorbit_ind</span> <span class="o">=</span> <span class="n">Pl1_maxorbit_sizes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maxorbit_all</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sigma0</span><span class="p">:</span>
            <span class="n">block_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pl1is</span><span class="p">[</span><span class="n">maxorbit_ind</span><span class="p">]</span>
            <span class="n">all_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pl1is</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">block_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">))])</span>
            <span class="p">)</span>
            <span class="n">all_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">Permutation</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">))]))</span>
            <span class="p">]</span>

    <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">block_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">l1i</span><span class="p">,</span> <span class="n">l2i</span> <span class="o">=</span> <span class="n">blockpair</span>
        <span class="n">inters1</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="n">l1i</span><span class="p">,</span> <span class="n">L_R</span><span class="p">)</span>
        <span class="n">is_sigma0</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l1i</span><span class="p">)</span> <span class="o">==</span> <span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l1i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l1i</span><span class="p">)</span>
        <span class="n">l2i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l2i</span><span class="p">)</span>
        <span class="c1"># intermediates hard coded for ramk 4 and 5 right now</span>
        <span class="n">inters1</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inter</span>
            <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="n">inters1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l1i</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l1i</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">inters2</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="n">l2i</span><span class="p">,</span> <span class="n">L_R</span><span class="p">)</span>
        <span class="n">inters2</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inter</span>
            <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="n">inters2</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l2i</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">inter</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">l2i</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sigma0</span><span class="p">:</span>
            <span class="n">L_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">L1i</span><span class="p">:</span> <span class="n">L2i</span> <span class="k">for</span> <span class="n">L1i</span><span class="p">,</span> <span class="n">L2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inters1</span><span class="p">,</span> <span class="n">inters2</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">L1i</span><span class="p">:</span> <span class="n">L1i</span> <span class="k">for</span> <span class="n">L1i</span><span class="p">,</span> <span class="n">L1i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inters1</span><span class="p">,</span> <span class="n">inters1</span><span class="p">)}</span>
    <span class="n">used_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">used_nl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">combined_labs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">super_inters_per_nl</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">lp</span><span class="p">,</span> <span class="n">nus</span> <span class="ow">in</span> <span class="n">blocks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
        <span class="n">degen_orbit</span><span class="p">,</span> <span class="n">orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
        <span class="n">block_pairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">blockpair</span>
            <span class="k">for</span> <span class="n">blockpair</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">block_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">blockpair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">blockpair</span> <span class="o">=</span> <span class="n">block_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># perm_map = block_map[block_pairs[0]]</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">perms_2_check</span> <span class="o">=</span> <span class="p">[</span><span class="n">block_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perms_2_check</span> <span class="o">=</span> <span class="p">[</span><span class="n">block_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">]]</span>
            <span class="c1"># perms_2_check = all_map[blockpair]</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">nus</span><span class="p">:</span>
            <span class="n">mu0ii</span><span class="p">,</span> <span class="n">muii</span><span class="p">,</span> <span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">,</span> <span class="n">Lii</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">is_sigma0</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lii</span><span class="p">)</span> <span class="o">==</span> <span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">degen_orbit</span><span class="p">,</span> <span class="n">orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
            <span class="n">nlii</span> <span class="o">=</span> <span class="p">[(</span><span class="n">niii</span><span class="p">,</span> <span class="n">liii</span><span class="p">)</span> <span class="k">for</span> <span class="n">niii</span><span class="p">,</span> <span class="n">liii</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">)]</span>
            <span class="n">atrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">perm_map</span> <span class="ow">in</span> <span class="n">perms_2_check</span><span class="p">:</span>
                <span class="n">remapped</span> <span class="o">=</span> <span class="n">perm_map</span><span class="p">(</span><span class="n">nlii</span><span class="p">)</span>
                <span class="n">newnii</span> <span class="o">=</span> <span class="p">[</span><span class="n">nliii</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">nliii</span> <span class="ow">in</span> <span class="n">remapped</span><span class="p">]</span>
                <span class="n">newlii</span> <span class="o">=</span> <span class="p">[</span><span class="n">nliii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">nliii</span> <span class="ow">in</span> <span class="n">remapped</span><span class="p">]</span>
                <span class="n">new_Lii</span> <span class="o">=</span> <span class="n">L_map</span><span class="p">[</span><span class="n">blockpair</span><span class="p">][</span><span class="n">Lii</span><span class="p">]</span>
                <span class="n">new_ltree</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">liii</span><span class="p">,</span> <span class="n">niii</span><span class="p">)</span> <span class="k">for</span> <span class="n">niii</span><span class="p">,</span> <span class="n">liii</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">newnii</span><span class="p">,</span> <span class="n">newlii</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">tree_i</span> <span class="o">=</span> <span class="n">build_full_tree</span><span class="p">(</span><span class="n">new_ltree</span><span class="p">,</span> <span class="n">Lii</span><span class="p">,</span> <span class="n">L_R</span><span class="p">)</span>
                <span class="c1"># tree_i =  build_tree(new_ltree,new_Lii,L_R)</span>
                <span class="n">tid</span> <span class="o">=</span> <span class="n">tree_i</span><span class="o">.</span><span class="n">tree_id</span>
                <span class="n">atrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
            <span class="n">cond1</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">tid</span> <span class="ow">in</span> <span class="n">used_ids</span> <span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">atrees</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">is_sigma0</span><span class="p">:</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">cond1</span> <span class="ow">and</span> <span class="n">cond2</span><span class="p">:</span>
                <span class="n">combined_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
                <span class="n">used_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
                <span class="n">used_nl</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newnii</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newlii</span><span class="p">)))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">super_inters_per_nl</span><span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newnii</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newlii</span><span class="p">))]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">new_Lii</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">super_inters_per_nl</span><span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newnii</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newlii</span><span class="p">))]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">new_Lii</span>
                    <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">combined_labs</span></div>



<span class="c1"># apply ladder relationships</span>
<div class="viewcode-block" id="apply_ladder_relationships">
<a class="viewcode-back" href="../../../../api/mala.descriptors.acelib.coupling_utils.html#mala.descriptors.acelib.coupling_utils.apply_ladder_relationships">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_ladder_relationships</span><span class="p">(</span>
    <span class="n">lin</span><span class="p">,</span> <span class="n">nin</span><span class="p">,</span> <span class="n">combined_labs</span><span class="p">,</span> <span class="n">parity_span</span><span class="p">,</span> <span class="n">parity_span_labs</span><span class="p">,</span> <span class="n">full_span</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply ladder relationships. From Goff 2024. For input angular function indices and radial function indices, apply ladder relationships to overcomplete set of L to remove redundant functions.</span>

<span class="sd">    These ladder relationships are derived from repeatedly applying raising/lowering relationships to the generalized coupling coefficients in https://doi.org/10.1016/j.jcp.2024.113073.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nin : List</span>
<span class="sd">        radial indices to resort according to frequency and return the mapping to do so</span>

<span class="sd">    lin : List</span>
<span class="sd">        angular indices to resort according to frequency and return the mapping to do so</span>

<span class="sd">    combined_labs : List</span>
<span class="sd">        blocks of lL generated based on frequency partition</span>

<span class="sd">    parity_span : List</span>
<span class="sd">        span of young subgroup * SO(3) after parity constraints applied</span>

<span class="sd">    parity_span_labs : List</span>
<span class="sd">        labels spanning young subgroup * SO(3) after parity constraints applied</span>

<span class="sd">    full_span : List</span>
<span class="sd">        span of full young subgroup * SO(3) group </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    funcs : List</span>
<span class="sd">        reduced set of permutation-adapted functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lin</span><span class="p">))</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">uniques</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">uniques</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="n">uniques</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniques</span><span class="p">))}</span>
    <span class="n">mappedl</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">]</span>
    <span class="n">ysgi</span> <span class="o">=</span> <span class="n">YoungSubgroup</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">unique_ns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nin</span><span class="p">))</span>
    <span class="n">tmpn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tmpn</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">unique_ns</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mp_n</span> <span class="o">=</span> <span class="p">{</span><span class="n">unique_ns</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ns</span><span class="p">))}</span>
    <span class="n">mappedn</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp_n</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmpn</span><span class="p">]</span>
    <span class="n">mappedn</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mappedn</span><span class="p">)</span>
    <span class="n">mappedl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mappedl</span><span class="p">)</span>

    <span class="n">max_labs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1">#  based on degeneracy</span>
    <span class="n">ndegen_rep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">mappedn</span><span class="p">)</span>
    <span class="n">ndegen_rep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ndegen_rep</span><span class="p">)</span>
    <span class="n">ndegen_rep</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ndegen_rep</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ndegen_rep</span><span class="p">)</span>
    <span class="n">degen_fam</span> <span class="o">=</span> <span class="p">(</span><span class="n">mappedl</span><span class="p">,</span> <span class="n">ndegen_rep</span><span class="p">)</span>

    <span class="n">all_inters</span> <span class="o">=</span> <span class="n">build_tree_for_l_intermediates</span><span class="p">(</span><span class="n">lin</span><span class="p">)</span>
    <span class="n">even_inters</span> <span class="o">=</span> <span class="n">simple_parity_filter</span><span class="p">(</span><span class="n">lin</span><span class="p">,</span> <span class="n">all_inters</span><span class="p">)</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">lin</span><span class="p">:</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="p">[</span>
                <span class="p">::</span><span class="mi">3</span>
            <span class="p">]</span> 
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">recurmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">max_labs</span><span class="p">:</span>
                <span class="n">mu0ii</span><span class="p">,</span> <span class="n">muii</span><span class="p">,</span> <span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">,</span> <span class="n">Lii</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span>
                    <span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">lidegen_rep</span><span class="p">,</span> <span class="n">l_orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">lii</span><span class="p">)</span>
                <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">),</span> <span class="p">[</span><span class="n">lidegen_rep</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">degen_nfills</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">recurmax</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nii</span><span class="p">)</span> <span class="ow">in</span> <span class="n">degen_nfills</span><span class="p">:</span>
                    <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">recurmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">max_labs</span><span class="p">:</span>
                <span class="n">mu0ii</span><span class="p">,</span> <span class="n">muii</span><span class="p">,</span> <span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">,</span> <span class="n">Lii</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span>
                    <span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">lidegen_rep</span><span class="p">,</span> <span class="n">l_orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">lii</span><span class="p">)</span>
                <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">),</span> <span class="p">[</span><span class="n">lidegen_rep</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">degen_nfills</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">recurmax</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nii</span><span class="p">)</span> <span class="ow">in</span> <span class="n">degen_nfills</span><span class="p">:</span>
                    <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">recurmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">max_labs</span><span class="p">:</span>
                <span class="n">mu0ii</span><span class="p">,</span> <span class="n">muii</span><span class="p">,</span> <span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">,</span> <span class="n">Lii</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span>
                    <span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">lidegen_rep</span><span class="p">,</span> <span class="n">l_orbit_inds</span> <span class="o">=</span> <span class="n">calculate_degenerate_orbit</span><span class="p">(</span><span class="n">lii</span><span class="p">)</span>
                <span class="n">l_sequential_degen_orbit</span> <span class="o">=</span> <span class="n">enforce_sorted_orbit</span><span class="p">(</span><span class="n">l_orbit_inds</span><span class="p">)</span>
                <span class="c1"># switch to lower symmetry SN representation</span>
                <span class="n">ysgi</span><span class="o">.</span><span class="n">subgroup_fill</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">nin</span><span class="p">),</span> <span class="p">[</span><span class="n">l_sequential_degen_orbit</span><span class="p">],</span> <span class="n">semistandard</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">degen_nfills</span> <span class="o">=</span> <span class="n">ysgi</span><span class="o">.</span><span class="n">fills</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">recurmax</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nii</span><span class="p">)</span> <span class="ow">in</span> <span class="n">degen_nfills</span><span class="p">:</span>
                    <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[</span>
                <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">parity_span_labs</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_inters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[</span>
                <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_inters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">combined_labs</span><span class="p">[::</span><span class="mi">4</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># from rank 5 ladder relationship</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">))]</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">))]</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">combined_labs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[</span>
                <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">degen_fam</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="p">]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">))]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">parity_span_labs</span><span class="p">:</span>
                <span class="n">mu0ii</span><span class="p">,</span> <span class="n">muii</span><span class="p">,</span> <span class="n">nii</span><span class="p">,</span> <span class="n">lii</span><span class="p">,</span> <span class="n">Lii</span> <span class="o">=</span> <span class="n">calculate_mu_n_l</span><span class="p">(</span>
                    <span class="n">lab</span><span class="p">,</span> <span class="n">return_L</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Lii</span><span class="p">:</span>
                    <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">degen_fam</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parity_span</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[</span>
                <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_labs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">even_inters</span><span class="p">))</span>
            <span class="p">]</span>

        <span class="k">elif</span> <span class="n">degen_fam</span> <span class="o">==</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">combined_labs</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_span</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ladder relationship found!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">funcs</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software. Attila Cangi, J. Austin Ellis, Lenz Fiedler, Daniel Kotik, Normand Modine, Sivasankaran Rajamanickam, Steve Schmerler, Aidan Thompson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>